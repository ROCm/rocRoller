
#include <rocRoller/CommandSolution.hpp>
#include <rocRoller/Expression.hpp>
#include <rocRoller/KernelGraph/Utils.hpp>
#include <rocRoller/KernelGraph/Visitors.hpp>
#include <rocRoller/Operations/Command.hpp>
#include <rocRoller/Operations/Operations.hpp>

namespace rocRoller
{
    namespace KernelGraph
    {
        namespace CT = rocRoller::KernelGraph::CoordinateGraph;
        using namespace ControlGraph;
        using namespace CoordinateGraph;
        using namespace Expression;
        using namespace Register;

        struct AddLDSVisitor
        {
            // Information generated by addLoadThroughLDSToCoordinates
            // that is needed by addLoadThroughLDSToControlGraph.
            struct ldsInfo
            {
                int loadTileFromGlobal;
                int storeTileIntoLDS;
                int lds;
                int internalTile;
            };

            AddLDSVisitor(std::shared_ptr<Context> context)
                : m_context(context)
            {
            }

            void addLoadThroughLDSToControlGraph(KernelGraph& graph, int forLoop)
            {
                auto bodies = graph.control.getOutputNodeIndices<Body>(forLoop).to<std::set>();

                // Find any Multiply commands directly under the For Loop.
                // Keep track of their loads and the entire body of the loop
                // that contains the Multiply.

                std::vector<int> loadAs;
                std::vector<int> loadBs;
                std::vector<int> bodiesWithMultiply;
                for(auto const& body : bodies)
                {
                    // Find all multiplies within the body
                    auto allMultiplies
                        = graph.control
                              .findNodes(
                                  body,
                                  [&](int tag) -> bool {
                                      return isOperation<Multiply>(graph.control.getElement(tag));
                                  },
                                  Graph::Direction::Downstream)
                              .to<std::vector>();

                    if(allMultiplies.empty())
                        continue;

                    // Make sure that the inner most loop that the Multiply
                    // resides in is the original for loop.
                    auto firstMultiply = allMultiplies[0];
                    auto allForLoops   = graph.control.findNodes(
                        firstMultiply,
                        [&](int tag) -> bool {
                            return isOperation<ForLoopOp>(graph.control.getElement(tag));
                        },
                        Graph::Direction::Upstream);

                    if(*allForLoops.begin() != forLoop)
                        continue;

                    bodiesWithMultiply.push_back(body);

                    auto loads
                        = graph.control.getOutputNodeIndices<Body>(firstMultiply).to<std::vector>();
                    AssertFatal(loads.size() == 2, "Multiply op needs two operands");

                    loadAs.push_back(loads[0]);
                    loadBs.push_back(loads[1]);
                }

                if(bodiesWithMultiply.empty())
                    return;

                // Call addLoadWaveLDSOps on A and B
                addLoadWaveLDSOps(graph, loadAs, forLoop, bodiesWithMultiply);
                addLoadWaveLDSOps(graph, loadBs, forLoop, bodiesWithMultiply);
            }

            void addLoadThroughLDSToCoordinates(KernelGraph& graph, int load);

        private:
            void addLoadWaveLDSOps(KernelGraph&     graph,
                                   std::vector<int> loads,
                                   int              forK,
                                   std::vector<int> loopBodies);

            // Key is MacroTile that will be loaded.
            // Value is information generated by addLoadThroughLDSToCoordinates
            // that is needed by addLoadThroughLDSToControlGraph.
            std::map<int, ldsInfo> m_info;

            ContextPtr m_context;
        };

        KernelGraph addLDS(KernelGraph const& original, std::shared_ptr<Context> context)
        {
            TIMER(t, "KernelGraph::addLDS");
            rocRoller::Log::getLogger()->debug("KernelGraph::addLDS()");

            auto k       = original;
            auto visitor = AddLDSVisitor(context);

            // Modify the coordinate graph to add LDS information
            for(auto const& load : k.control.getNodes<LoadTiled>().to<std::vector>())
            {
                auto macroTileTag      = k.mapper.get<MacroTile>(load);
                auto macroTile         = k.coordinates.getNode<MacroTile>(macroTileTag);
                auto macroTileLocation = k.coordinates.getLocation(macroTileTag);
                // Only modify the coordinate graph for a load whose associated MacroTile
                // is not a duplicate created by an unroll.
                if(macroTile.memoryType == MemoryType::WAVE_LDS
                   && !macroTileLocation.incoming.empty())
                {
                    visitor.addLoadThroughLDSToCoordinates(k, load);
                }
            }

            // Add nodes to the control graph to load data through
            // LDS.
            for(auto const& forLoop : k.control.getNodes<ForLoopOp>())
            {
                visitor.addLoadThroughLDSToControlGraph(k, forLoop);
            }

            return k;
        }

        // Add LDSLoad and LDSStore nodes following a LoadTiled node within
        // the control graph, if the tile has a memory type of LDS.
        void addLDSOps(KernelGraph& graph, std::shared_ptr<Context> context, int tag)
        {
            auto userTag = graph.mapper.get<User>(tag);
            auto tileTag = graph.mapper.get<MacroTile>(tag);
            auto tile    = graph.coordinates.getNode<MacroTile>(tileTag);
            auto load    = graph.control.getNode<LoadTiled>(tag);

            if(tile.memoryType == MemoryType::LDS)
            {
                // change loadTiled to LoadLDSTile
                graph.control.setElement(tag, LoadLDSTile(load.vtype));

                graph.coordinates.deleteElement(
                    std::vector<int>{userTag}, std::vector<int>{tileTag}, CT::isEdge<DataFlow>);
                auto sdims = graph.coordinates.getOutputNodeIndices(userTag, CT::isEdge<Split>)
                                 .to<std::vector>();

                auto lds = graph.coordinates.addElement(LDS());

                // remove workgroups, macrotile numbers and tile edges from sdims
                updateLoadLDSMacroTile(graph, tile, tag, sdims, -1, lds);

                // add new loadTiled node to load a macrotile into VGPRs from global memory
                auto loadMacroTileFromGlobal = graph.control.addElement(LoadTiled(load.vtype));
                graph.mapper.connect<User>(loadMacroTileFromGlobal, userTag);

                // Find all incoming edges into tag. Those should be changed to come into loadMacroTileFromGlobal.
                auto incomingEdges = graph.control.getNeighbours<Graph::Direction::Upstream>(tag)
                                         .to<std::vector>();
                for(auto e : incomingEdges)
                {
                    auto elem = graph.control.getElement(e);
                    auto src  = graph.control.getNeighbours<Graph::Direction::Upstream>(e)
                                   .to<std::vector>();
                    graph.control.deleteElement(e);
                    graph.control.addElement(
                        e, elem, src, std::vector<int>{loadMacroTileFromGlobal});
                }

                // create an internal macrotile to be loaded by one workgroup
                auto workgroupSizes = context->kernel()->workgroupSize();
                auto internalTile   = graph.coordinates.addElement(
                    MacroTile(tile.sizes, MemoryType::VGPR, tile.subTileSizes));
                auto internalTileDim = graph.coordinates.getNode<MacroTile>(internalTile);
                graph.coordinates.setElement(internalTile, internalTileDim);
                graph.mapper.connect<MacroTile>(loadMacroTileFromGlobal, internalTile);

                // user --DataFlow--> internalTile
                graph.coordinates.addElement(DataFlow(), {userTag}, {internalTile});

                // lower tile LoadTiled : load macrotile from global memory
                loadMacroTileForLDS(graph,
                                    loadMacroTileFromGlobal,
                                    userTag,
                                    internalTile,
                                    sdims,
                                    -1,
                                    workgroupSizes,
                                    context);

                // add store from VGPRs to LDS following this new loadTiled
                auto storeMacroTileIntoLDSNode
                    = graph.control.addElement(StoreLDSTile(load.vtype.dataType));
                auto barrier = graph.control.addElement(Barrier());
                graph.control.addElement(
                    Sequence(), {loadMacroTileFromGlobal}, {storeMacroTileIntoLDSNode});
                graph.control.addElement(Sequence(), {storeMacroTileIntoLDSNode}, {barrier});
                graph.control.addElement(Sequence(), {barrier}, {tag});
                graph.mapper.connect<MacroTile>(storeMacroTileIntoLDSNode, internalTile);

                // lower tile StoreLDSTile : store macrotile into LDS
                storeMacroTileIntoLDS(
                    graph, storeMacroTileIntoLDSNode, lds, internalTile, workgroupSizes, context);

                // LDS --DataFlow--> macrotile
                graph.coordinates.addElement(DataFlow(), {lds}, {tileTag});

                graph.mapper.connect<LDS>(tag, lds);
                graph.mapper.connect<LDS>(loadMacroTileFromGlobal, lds);
                graph.mapper.connect<LDS>(storeMacroTileIntoLDSNode, lds);
            }
        }

        void AddLDSVisitor::addLoadWaveLDSOps(KernelGraph&     graph,
                                              std::vector<int> loads,
                                              int              forK,
                                              std::vector<int> loopBodies)
        {
            rocRoller::Log::getLogger()->debug("KernelGraph::addLoadWaveLDSOps: For({})", forK);

            int user = graph.mapper.get<User>(loads[0]);

            // Ensure that all loads have the same User value
            for(auto const& load : loads)
            {
                AssertFatal(graph.mapper.get<User>(load) == user,
                            "All loads should have same User value");
            }

            auto macrotile
                = graph.coordinates.getNode<MacroTile>(graph.mapper.get<MacroTile>(loads[0]));

            if(macrotile.memoryType == MemoryType::WAVE_LDS)
            {
                // Find all of the loads macro tiles and see if they are in the
                // info map. If not, use passthrough edge to find macrotile.
                int  origMacroTile = -1;
                bool origInLoads   = false;
                for(auto const& load : loads)
                {
                    auto macroTile = graph.mapper.get<MacroTile>(load);
                    if(m_info.count(macroTile) == 1)
                    {
                        origInLoads   = true;
                        origMacroTile = macroTile;
                    }
                    else
                    {
                        auto orig = graph.coordinates
                                        .getOutputNodeIndices(macroTile, CT::isEdge<PassThrough>)
                                        .to<std::vector>();
                        AssertFatal(orig.size() == 1);
                        origMacroTile = orig[0];
                    }
                }
                AssertFatal(m_info.count(origMacroTile) == 1);
                auto localInfo = m_info[origMacroTile];

                auto vtype           = graph.control.getNode<LoadTiled>(loads[0]).vtype;
                macrotile.memoryType = MemoryType::WAVE;

                // change loadTiled to LoadLDSTile under Multiply
                for(auto const& load : loads)
                {
                    graph.control.setElement(load, LoadLDSTile(vtype));
                    auto loadTile = graph.mapper.get<MacroTile>(load);
                    graph.coordinates.setElement(loadTile, macrotile);
                    auto loadTileLocation = graph.coordinates.getLocation(loadTile);
                    graph.mapper.connect<LDS>(load, localInfo.lds);
                    for(auto const& c : graph.mapper.getConnections(load))
                    {
                        if(!graph.coordinates.exists(c.coordinate))
                        {
                            graph.mapper.disconnect(load, c.coordinate, c.connection);
                        }
                    }
                }

                // If not using data from the info map, create new nodes,
                // otherwise use the nodes previously created in addLoadThroughLDSToCoordinates.
                int loadTileFromGlobal;
                int internalTile;
                int storeTileIntoLDS;
                if(!origInLoads)
                {
                    internalTile = graph.coordinates.addElement(
                        graph.coordinates.getNode<MacroTile>(localInfo.internalTile));
                    graph.coordinates.addElement(
                        PassThrough(), {internalTile}, {localInfo.internalTile});

                    loadTileFromGlobal = graph.control.addElement(LoadTiled(vtype));
                    for(auto const& c : graph.mapper.getConnections(localInfo.loadTileFromGlobal))
                    {
                        graph.mapper.connect(loadTileFromGlobal, c.coordinate, c.connection);
                    }

                    storeTileIntoLDS = graph.control.addElement(StoreLDSTile(vtype.dataType));
                    for(auto const& c : graph.mapper.getConnections(localInfo.storeTileIntoLDS))
                    {
                        graph.mapper.connect(storeTileIntoLDS, c.coordinate, c.connection);
                    }
                }
                else
                {
                    loadTileFromGlobal = localInfo.loadTileFromGlobal;
                    internalTile       = localInfo.internalTile;
                    storeTileIntoLDS   = localInfo.storeTileIntoLDS;
                }

                graph.mapper.connect<MacroTile>(loadTileFromGlobal, internalTile);
                graph.mapper.connect<User>(loadTileFromGlobal, user);
                graph.mapper.connect<LDS>(loadTileFromGlobal, localInfo.lds);

                graph.mapper.connect<MacroTile>(storeTileIntoLDS, internalTile);
                graph.mapper.connect<LDS>(storeTileIntoLDS, localInfo.lds);

                graph.control.addElement(Body(), {forK}, {loadTileFromGlobal});

                // iteration barrier (right before StoreLDSTile) to ensure that no worker could write into
                // the same portion of LDS while another worker is reading from it in a previous iteration.
                auto iterationBarrier = graph.control.addElement(Barrier());
                graph.control.addElement(Sequence(), {loadTileFromGlobal}, {iterationBarrier});
                graph.control.addElement(Sequence(), {iterationBarrier}, {storeTileIntoLDS});

                auto barrier = graph.control.addElement(Barrier());
                graph.control.addElement(Sequence(), {storeTileIntoLDS}, {barrier});
                for(auto const& loopBody : loopBodies)
                {
                    graph.control.addElement(Sequence(), {barrier}, {loopBody});
                }
            }
        }

        void AddLDSVisitor::addLoadThroughLDSToCoordinates(KernelGraph& graph, int load)
        {
            ldsInfo localInfo;
            auto    loadTile  = graph.mapper.get<MacroTile>(load);
            auto    macrotile = graph.coordinates.getNode<MacroTile>(loadTile);

            if(macrotile.memoryType == MemoryType::WAVE_LDS)
            {
                auto vtype = graph.control.getNode<LoadTiled>(load).vtype;
                int  user  = graph.mapper.get<User>(load);
                auto sdims = graph.coordinates.getOutputNodeIndices(user, CT::isEdge<Split>)
                                 .to<std::vector>();

                localInfo.lds = graph.coordinates.addElement(LDS());

                // Find K dimension
                auto allForLoops = graph.control.findNodes(
                    load,
                    [&](int tag) -> bool {
                        return isOperation<ForLoopOp>(graph.control.getElement(tag));
                    },
                    Graph::Direction::Upstream);
                auto forK        = *allForLoops.begin();
                auto connections = graph.mapper.getConnections(forK);
                AssertFatal(connections.size() == 1);
                auto loop_incr_tag = connections[0].coordinate;
                auto loopDims = graph.coordinates.getOutputNodeIndices<DataFlowEdge>(loop_incr_tag)
                                    .to<std::vector>();
                AssertFatal(loopDims.size() == 1);
                auto K = loopDims[0];

                // remove workgroups, macrotile numbers and tile edges from sdims
                updateLoadLDSMacroTile(graph, macrotile, load, sdims, K, localInfo.lds);

                // create an internal macrotile to be loaded by one workgroup
                auto workgroupSizes         = m_context->kernel()->workgroupSize();
                auto numWorkitems           = product(workgroupSizes);
                auto numElements            = product(macrotile.sizes);
                auto numElementsPerWorkitem = static_cast<int>(numElements / numWorkitems);
                auto thrTileM               = numElementsPerWorkitem;
                auto thrTileN               = 1;

                // load multiple smaller-precision(< 32-bit) elements into 1 VGPR
                auto packFactor = bytesPerRegister / DataTypeInfo::Get(vtype).elementSize;
                bool packed     = false;
                if(m_context->kernelOptions().packMultipleElementsInto1VGPR && packFactor > 1
                   && thrTileM % packFactor == 0)
                {
                    thrTileM = thrTileM / packFactor;
                    thrTileN = packFactor;

                    packed = true;
                }

                // enable the use of longer word instructions if possible
                if(m_context->kernelOptions().enableLongDwordInstructions
                   && (packed || packFactor <= 1))
                {
                    auto maxWidth = std::min(m_context->kernelOptions().loadGlobalWidth,
                                             m_context->kernelOptions().storeLocalWidth);

                    auto numDwordsPerElement
                        = std::max(1LU, DataTypeInfo::Get(vtype).elementSize / bytesPerRegister);

                    updateThreadTileForLongDwords(
                        thrTileM, thrTileN, maxWidth, numDwordsPerElement);
                }

                localInfo.internalTile = graph.coordinates.addElement(
                    MacroTile(macrotile.sizes, MemoryType::VGPR, {thrTileM, thrTileN}));
                auto internalTileDim = graph.coordinates.getNode<MacroTile>(localInfo.internalTile);
                internalTileDim.layoutType = macrotile.layoutType;
                graph.coordinates.setElement(localInfo.internalTile, internalTileDim);

                // user --DataFlow--> internalTile
                graph.coordinates.addElement(DataFlow(), {user}, {localInfo.internalTile});
                localInfo.loadTileFromGlobal = graph.control.addElement(LoadTiled(vtype));
                graph.mapper.connect<User>(localInfo.loadTileFromGlobal, user);
                // lower tile LoadTiled : load macrotile from global memory
                loadMacroTileForLDS(graph,
                                    localInfo.loadTileFromGlobal,
                                    user,
                                    localInfo.internalTile,
                                    sdims,
                                    K,
                                    workgroupSizes,
                                    m_context);

                localInfo.storeTileIntoLDS = graph.control.addElement(StoreLDSTile(vtype.dataType));
                // lower tile StoreLDSTile : store macrotile into LDS
                storeMacroTileIntoLDS(graph,
                                      localInfo.storeTileIntoLDS,
                                      localInfo.lds,
                                      localInfo.internalTile,
                                      workgroupSizes,
                                      m_context);
                graph.coordinates.deleteElement(
                    std::vector<int>{user}, std::vector<int>{loadTile}, CT::isEdge<DataFlow>);
                graph.coordinates.addElement(DataFlow(), {localInfo.lds}, {loadTile});

                m_info[loadTile] = localInfo;
            }
        }

        void addStoreWaveLDSOps(KernelGraph&                       graph,
                                std::shared_ptr<CommandParameters> params,
                                std::shared_ptr<Context>           context,
                                int                                tile,
                                int                                store,
                                int                                upperLoop)
        {
            rocRoller::Log::getLogger()->debug(
                "KernelGraph::LowerTileVisitor::addStoreWaveLDSOps: StoreTiled({})", store);

            auto macrotile = graph.coordinates.getNode<MacroTile>(tile);

            if(macrotile.memoryType == MemoryType::WAVE_LDS)
            {
                // change StoreTiled to StoreLDSTile
                // and update its macrotile's memory type
                auto dtype = graph.control.getNode<StoreTiled>(store).dataType;
                graph.control.setElement(store, StoreLDSTile(dtype));
                macrotile.memoryType = MemoryType::WAVE;
                graph.coordinates.setElement(tile, macrotile);

                auto storeDBarrierRW = graph.control.addElement(Barrier());
                // Find all incoming edges into StoreLDSTile.
                // Those should be changed to come into Barrier to avoid RW hazard.
                auto incoming_edges = graph.control.getNeighbours<Graph::Direction::Upstream>(store)
                                          .to<std::vector>();
                for(auto e : incoming_edges)
                {
                    auto elem = graph.control.getElement(e);
                    auto src  = graph.control.getNeighbours<Graph::Direction::Upstream>(e)
                                   .to<std::vector>();
                    graph.control.deleteElement(e);
                    graph.control.addElement(e, elem, src, std::vector<int>{storeDBarrierRW});
                }
                graph.control.addElement(Sequence(), {storeDBarrierRW}, {store});

                auto user = graph.coordinates.getOutputNodeIndices(tile, CT::isEdge<DataFlow>)
                                .to<std::vector>();
                AssertFatal(user.size() == 1);
                graph.coordinates.deleteElement(std::vector<int>{tile}, user, CT::isEdge<DataFlow>);
                auto sdims = graph.coordinates.getInputNodeIndices(user[0], CT::isEdge<Join>)
                                 .to<std::vector>();
                AssertFatal(sdims.size() > 1);

                auto lds = graph.coordinates.addElement(LDS());

                // remove workgroups, macrotile numbers and tile edges from sdims
                updateStoreLDSMacroTile(graph, macrotile, store, sdims, lds);

                // macrotile --DataFlow--> LDS
                graph.coordinates.addElement(DataFlow(), {tile}, {lds});
                graph.mapper.connect<LDS>(store, lds);

                auto barrier = graph.control.addElement(Barrier());
                graph.control.addElement(Sequence(), {store}, {barrier});

                // add new loadLDSTile node to load a macrotile into VGPRs from LDS
                auto loadMacroTileFromLDSNode
                    = graph.control.addElement(LoadLDSTile(VariableType(dtype)));
                graph.mapper.connect<LDS>(loadMacroTileFromLDSNode, lds);
                graph.control.addElement(Sequence(), {upperLoop}, {loadMacroTileFromLDSNode});

                // create an internal macrotile to be loaded by one workgroup
                auto workgroupSizes         = context->kernel()->workgroupSize();
                auto numWorkitems           = product(workgroupSizes);
                auto numElements            = product(macrotile.sizes);
                auto numElementsPerWorkitem = static_cast<int>(numElements / numWorkitems);
                auto thrTileM               = numElementsPerWorkitem;
                auto thrTileN               = 1;

                // load multiple smaller-precision(< 32-bit) elements into 1 VGPR
                auto packFactor = bytesPerRegister / DataTypeInfo::Get(dtype).elementSize;
                bool packed     = false;
                if(context->kernelOptions().packMultipleElementsInto1VGPR && packFactor > 1
                   && thrTileM % packFactor == 0)
                {
                    thrTileM = thrTileM / packFactor;
                    thrTileN = packFactor;

                    packed = true;
                }

                // enable the use of longer word instructions if possible
                if(context->kernelOptions().enableLongDwordInstructions
                   && (packed || packFactor <= 1))
                {
                    auto maxWidth = std::min(context->kernelOptions().storeGlobalWidth,
                                             context->kernelOptions().loadLocalWidth);

                    auto numDwordsPerElement
                        = std::max(1LU, DataTypeInfo::Get(dtype).elementSize / bytesPerRegister);

                    updateThreadTileForLongDwords(
                        thrTileM, thrTileN, maxWidth, numDwordsPerElement);
                }

                auto internalTile = graph.coordinates.addElement(
                    MacroTile(macrotile.sizes, MemoryType::VGPR, {thrTileM, thrTileN}));
                auto internalTileDim       = graph.coordinates.getNode<MacroTile>(internalTile);
                internalTileDim.layoutType = macrotile.layoutType;
                graph.coordinates.setElement(internalTile, internalTileDim);
                graph.mapper.connect<MacroTile>(loadMacroTileFromLDSNode, internalTile);

                // lower tile LoadLDSTile : load macrotile from LDS
                loadMacroTileFromLDS(
                    graph, loadMacroTileFromLDSNode, lds, internalTile, workgroupSizes);

                // add store from VGPRs to global following this new loadLDSTile
                auto storeMacroTileIntoGlobal = graph.control.addElement(StoreTiled(dtype));
                graph.control.addElement(
                    Sequence(), {loadMacroTileFromLDSNode}, {storeMacroTileIntoGlobal});
                graph.mapper.connect<MacroTile>(storeMacroTileIntoGlobal, internalTile);
                graph.mapper.connect<User>(storeMacroTileIntoGlobal, user[0]);
                // internalTile --DataFlow--> user
                graph.coordinates.addElement(DataFlow(), {internalTile}, {user[0]});

                storeMacroTileForLDS(
                    graph, storeMacroTileIntoGlobal, user[0], internalTile, sdims, workgroupSizes);
            }
        }
    }
}
